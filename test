
Sure, using a native query might make it easier to directly reference the tables and columns involved. Here’s how you can achieve the same goal using a native query:

### Step 1: Define the Native Query

You will write a native SQL query to join the necessary tables and select the required fields.

### Step 2: Define the DTO Class

Create a simple DTO class to hold the result of the query with the necessary fields.

### Step 3: Update the Repository Method to Return the DTO

### Step 1: Define the Native Query

Here’s the native query that joins the necessary tables and selects the required fields:

```java
@Query(value = "SELECT DISTINCT t.id, t.name, c1.first_name AS createdByFirstName, c1.last_name AS createdByLastName, " +
               "c2.first_name AS modifiedByFirstName, c2.last_name AS modifiedByLastName " +
               "FROM contact_template t " +
               "LEFT JOIN contact_platform_login cpl1 ON t.created_by = cpl1.platform_login " +
               "LEFT JOIN contact c1 ON cpl1.contact_id = c1.id " +
               "LEFT JOIN contact_platform_login cpl2 ON t.modified_by = cpl2.platform_login " +
               "LEFT JOIN contact c2 ON cpl2.contact_id = c2.id " +
               "WHERE t.owner_ecold = :enablementContactId " +
               "OR :enablementContactId IN (SELECT u.enablement_contact_id FROM shared_with_contacts u WHERE u.contact_template_id = t.id)", nativeQuery = true)
List<ContactTemplateDto> findAllByOwnerEcoIdOrSharedWithContacts(@Param("enablementContactId") String enablementContactId);
```

### Step 2: Define the DTO Class

Make sure you have the `ContactTemplateDto` class defined:

```java
package com.example.dto;

public class ContactTemplateDto {
    private Long id;
    private String name;
    private String createdByFirstName;
    private String createdByLastName;
    private String modifiedByFirstName;
    private String modifiedByLastName;

    // Constructor
    public ContactTemplateDto(Long id, String name, String createdByFirstName, String createdByLastName, String modifiedByFirstName, String modifiedByLastName) {
        this.id = id;
        this.name = name;
        this.createdByFirstName = createdByFirstName;
        this.createdByLastName = createdByLastName;
        this.modifiedByFirstName = modifiedByFirstName;
        this.modifiedByLastName = modifiedByLastName;
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCreatedByFirstName() {
        return createdByFirstName;
    }

    public void setCreatedByFirstName(String createdByFirstName) {
        this.createdByFirstName = createdByFirstName;
    }

    public String getCreatedByLastName() {
        return createdByLastName;
    }

    public void setCreatedByLastName(String createdByLastName) {
        this.createdByLastName = createdByLastName;
    }

    public String getModifiedByFirstName() {
        return modifiedByFirstName;
    }

    public void setModifiedByFirstName(String modifiedByFirstName) {
        this.modifiedByFirstName = modifiedByFirstName;
    }

    public String getModifiedByLastName() {
        return modifiedByLastName;
    }

    public void setModifiedByLastName(String modifiedByLastName) {
        this.modifiedByLastName = modifiedByLastName;
    }
}
```

### Step 3: Update the Repository Method to Return the DTO

Ensure your repository interface method returns the new DTO:

```java
public interface ContactTemplateRepository extends JpaRepository<ContactTemplate, Long> {
    
    @Query(value = "SELECT DISTINCT t.id, t.name, c1.first_name AS createdByFirstName, c1.last_name AS createdByLastName, " +
                   "c2.first_name AS modifiedByFirstName, c2.last_name AS modifiedByLastName " +
                   "FROM contact_template t " +
                   "LEFT JOIN contact_platform_login cpl1 ON t.created_by = cpl1.platform_login " +
                   "LEFT JOIN contact c1 ON cpl1.contact_id = c1.id " +
                   "LEFT JOIN contact_platform_login cpl2 ON t.modified_by = cpl2.platform_login " +
                   "LEFT JOIN contact c2 ON cpl2.contact_id = c2.id " +
                   "WHERE t.owner_ecold = :enablementContactId " +
                   "OR :enablementContactId IN (SELECT u.enablement_contact_id FROM shared_with_contacts u WHERE u.contact_template_id = t.id)", nativeQuery = true)
    List<ContactTemplateDto> findAllByOwnerEcoIdOrSharedWithContacts(@Param("enablementContactId") String enablementContactId);
}
```

### Summary

This simplified approach uses a native SQL query to fetch the required data, which directly joins the necessary tables and maps the results to the `ContactTemplateDto` class. This makes the implementation more straightforward and easier to understand.
